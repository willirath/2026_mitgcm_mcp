"""Recommended tool workflows for common agent tasks.

Returns structured guidance so agents can orient themselves at the start
of a session without relying on implicit knowledge of the tool set.
"""

_WORKFLOWS: dict = {
    "design_experiment": {
        "description": (
            "Design a new MITgcm experiment from physical parameters. "
            "Start from existing verification experiments, study their choices, "
            "then diverge to match your setup."
        ),
        "steps": [
            {
                "tool": "list_verification_experiments_tool",
                "purpose": (
                    "Find relevant verification experiments by filtering on physics "
                    "flags (nonhydrostatic, rigid lid, EOS type), packages, and grid "
                    "type. Study multiple experiments — not just one — to understand "
                    "the range of valid choices."
                ),
            },
            {
                "tool": "search_verification_tool",
                "purpose": (
                    "Search the namelist content of relevant experiments for specific "
                    "parameters or patterns (e.g. 'nonHydrostatic', 'f0', 'RBCS'). "
                    "Use alongside list_verification_experiments_tool to find "
                    "experiments that configure the physics closest to your goal."
                ),
            },
            {
                "tool": "get_doc_source_tool",
                "purpose": (
                    "Read the full input/data and code/SIZE.h of the most relevant "
                    "experiments. Use the file paths returned by "
                    "search_verification_tool or list_verification_experiments_tool. "
                    "These are your starting templates — copy and diverge."
                ),
            },
            {
                "tool": "translate_lab_params_tool",
                "purpose": (
                    "Convert physical lab parameters (tank size, rotation rate, "
                    "temperature contrast) to MITgcm namelist values."
                ),
            },
            {
                "tool": "check_scales_tool",
                "purpose": (
                    "Compute dimensionless numbers (Ek, Ro, Bu) and check CFL / "
                    "Ekman resolution. Resolve flagged warnings before proceeding."
                ),
            },
            {
                "tool": "lookup_gotcha_tool",
                "purpose": (
                    "Search the gotcha catalogue for known traps relevant to your "
                    "setup (e.g. 'nonhydrostatic', 'rigid lid', 'RBCS', 'spin-up', "
                    "'readBinaryPrec', 'SIZE.h')."
                ),
            },
            {
                "tool": "suggest_experiment_config_tool",
                "purpose": (
                    "Get skeleton CPP_OPTIONS.h, namelist stanzas, and a Docker "
                    "build/run recipe for the experiment type. Use as a checklist "
                    "against the verification experiment templates you already have."
                ),
            },
        ],
        "notes": [
            "Start from verification experiments, not from scratch — they encode working configurations.",
            "Input files (.bin, NetCDF, etc.) are not generated by these tools — write a Python script.",
            "The 'quickstart' key in suggest_experiment_config_tool output has the Docker build and run commands.",
            "Follow up with get_workflow_tool('validate_incrementally') before a full production run.",
        ],
    },
    "debug_configuration": {
        "description": "Diagnose why a configuration does not compile or run correctly.",
        "steps": [
            {
                "tool": "lookup_gotcha_tool",
                "purpose": (
                    "Search by symptom first (e.g. 'CFL instability', "
                    "'DIAGNOSTICS_SIZE', 'rigid lid', 'nonhydrostatic')."
                ),
            },
            {
                "tool": "namelist_to_code_tool",
                "purpose": "Find which subroutine reads a suspect namelist parameter.",
            },
            {
                "tool": "get_source_tool",
                "purpose": "Read the subroutine source to understand what the parameter controls.",
            },
            {
                "tool": "get_cpp_requirements_tool",
                "purpose": "Check which CPP flags must be defined for a subroutine to compile in.",
            },
            {
                "tool": "search_code_tool",
                "purpose": "Semantic search when you don't know the subroutine name.",
            },
        ],
        "notes": [],
    },
    "understand_package": {
        "description": "Learn what a MITgcm package does and how to configure it.",
        "steps": [
            {
                "tool": "search_docs_tool",
                "purpose": "Search documentation for the package name and behaviour.",
            },
            {
                "tool": "get_package_flags_tool",
                "purpose": "List all compile-time CPP flags the package exposes.",
            },
            {
                "tool": "find_subroutines_tool",
                "purpose": "Find key subroutines by name (e.g. PKG_INIT, PKG_READPARMS).",
            },
            {
                "tool": "get_source_tool",
                "purpose": "Read subroutine source for implementation details.",
            },
            {
                "tool": "get_callers_tool",
                "purpose": "Trace where the package is called from in the model loop.",
            },
        ],
        "notes": [],
    },
    "explore_code": {
        "description": "Navigate MITgcm source to answer a specific code question.",
        "steps": [
            {
                "tool": "search_code_tool",
                "purpose": "Semantic search when you don't know the subroutine name.",
            },
            {
                "tool": "find_subroutines_tool",
                "purpose": "Look up a subroutine by exact name.",
            },
            {
                "tool": "get_source_tool",
                "purpose": "Read source, paginated with offset/limit for large routines.",
            },
            {
                "tool": "get_callers_tool",
                "purpose": "Find what calls this subroutine.",
            },
            {
                "tool": "get_callees_tool",
                "purpose": "Find what this subroutine calls.",
            },
            {
                "tool": "diagnostics_fill_to_source_tool",
                "purpose": "Find which subroutine fills a named diagnostics output field.",
            },
        ],
        "notes": [],
    },
    "validate_incrementally": {
        "description": (
            "Validate a MITgcm experiment through four staged goals before committing "
            "to a full production run. Each stage is a gate: do not proceed until the "
            "current stage passes. For a new experiment built from scratch, add and "
            "validate one physics component at a time — reach stage 2 after each "
            "addition before adding the next."
        ),
        "steps": [
            {
                "tool": None,
                "purpose": (
                    "Stage 1 — Build succeeds. "
                    "Run docker build (or equivalent). The model must compile without "
                    "errors. Common causes of failure: missing CPP flag, wrong SIZE.h "
                    "constraints, packages listed in data.pkg but not in packages.conf. "
                    "Use lookup_gotcha_tool and get_cpp_requirements_tool to diagnose."
                ),
            },
            {
                "tool": None,
                "purpose": (
                    "Stage 2 — Model starts. "
                    "Set nTimeSteps=2 and run. Even a dynamic blowup (NaN, CFL "
                    "exceeded) at this stage is a success — it confirms the binary "
                    "is correct and the model initialises. What must NOT happen: "
                    "abort at startup (CONFIG_CHECK, PACKAGES_CHECK, missing input "
                    "file, DIAGNOSTICS_SIZE too small). Fix any startup aborts before "
                    "proceeding. For new experiments: add one component (e.g. EOS, "
                    "then RBCS, then diagnostics), reach stage 2 after each addition."
                ),
            },
            {
                "tool": None,
                "purpose": (
                    "Stage 3 — Physically plausible output. "
                    "Increase nTimeSteps enough to see the flow develop. Check "
                    "STDOUT.0000 for: n3dWetPts (must be > 0), theta_mean (must be "
                    "finite and near the initial value), dynstat diagnostics (velocity "
                    "and temperature RMS must be finite and physically reasonable). "
                    "Consider a minimal domain (coarsest resolution, smallest Nx/Ny/Nr "
                    "that preserves the physics) to keep turnaround fast at this stage. "
                    "Use check_scales_tool to confirm CFL and Ekman layer resolution "
                    "are satisfied."
                ),
            },
            {
                "tool": None,
                "purpose": (
                    "Stage 4 — Production run. "
                    "Scale to full domain, full duration. Set nTimeSteps, dumpFreq, "
                    "and chkPtFreq for the intended run. Mount an output volume "
                    "(see suggest_experiment_config_tool quickstart.run) and verify "
                    "diagnostics files are written."
                ),
            },
        ],
        "notes": [
            "Stage 2 dynamic blowup is acceptable — it means initialisation succeeded.",
            "Fix startup aborts (stage 2) before investigating physics (stage 3).",
            "For new experiments: one component at a time, stage-2 gate after each.",
            "Coarse resolution at stage 3 is fine — scale up only at stage 4.",
            "Use lookup_gotcha_tool('CFL') and lookup_gotcha_tool('DIAGNOSTICS_SIZE') for common stage-2/3 failures.",
        ],
    },
}


def get_workflow(task: str | None = None) -> dict:
    """Return recommended tool sequences for common tasks.

    Parameters
    ----------
    task : str or None
        One of "design_experiment", "debug_configuration",
        "understand_package", "explore_code", "validate_incrementally".
        If None, all workflows are returned.

    Returns
    -------
    dict
        Mapping of task name to workflow dict with keys:
        description, steps (list of {tool, purpose}), notes.
        Empty dict if the task name is not recognised.
    """
    if task is not None:
        key = task.lower().strip().replace(" ", "_")
        return {key: _WORKFLOWS[key]} if key in _WORKFLOWS else {}
    return dict(_WORKFLOWS)
